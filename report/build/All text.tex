\section{Introduction}
The motivation behind this project was to build a mobile robot capable of walking across various ground surfaces, combining both mechanical movement and wireless control. Unlike wheeled robots, a legged design can adapt more easily to uneven or soft terrain, making it more able to move in real-world environments. We also introduce a further addition in making the robot controllable in real time via a Bluetooth connection to an app. The finished robot can be seen in figure: \ref{fig:robot}

\section{Background}
The concept of using mechanical linkages to create walking robots is not new. The Theo Jansen linkage, originally designed by kinetic artist Theo Jansen for wind-powered sculptures called "Strandbeests", has been used in previous robotics research with a focus on gait analysis \cite{nansai2013dynamicanalysis} \cite{hernandez2016homemade} for its ability to generate smooth, lifelike walking motion using a single rotary actuator. 

Projects similar to this has been done, an example being \cite{jeremySCook}, in which a premade Strandbeest kit was adapted to be remote controlled. In addition, previous work has also been done using the ultrasonic sensor for obstacle detection. But, to the best of our knowledge no one has combined both obstacle detection, remote controllability and OEM parts. 

Other additions as actuated feet on the legs to increase traction, and a modular design that making it easier to extend the number of legs. 

\section{Requirements}
To meet the project goals, the robot was designed with the following requirements:

\begin{itemize}
    \item  The robot must use Theo Jansen-style mechanical linkages for walking, powered by two DC motors.
    \item The robot must support Bluetooth control via a mobile app, allowing the user to steer and adjust speed remotely.
    \item  An ultrasonic distance sensor must detect obstacles and trigger braking.
    \item The robot must operate on battery power to ensure mobility.
    \item The design should support easy extension of the number of legs, with a mechanical structure that allows scaling.
    \item Legs must be fitted with actuated feet to increase grip and reduce slipping on smooth surfaces.
    \item The robot should be able to move reliably on a variety of surfaces.
\end{itemize}

\begin{figure}[!htb]
    \centering
    \includegraphics[width=1\linewidth]{images/Roboty.jpg}
    \caption{Assembled robot}
    \label{fig:robot}
\end{figure}

\section{Description}
%How does your device work? Describe in as much detail as you can fit into the report. It should contain three subsections: Mechanics, Electronics and software/Firmware. Describe also what alternatives you analyzed for the different parts of your device. Why did you select the alternative that you finally used?
\input{TechnicalDescription}
\section{Results/Analysis}
%Did it work properly? What kind of tests did you run to test your prototype? Could you provide some data that shows the performance of the prototype (speed, success rate, etc.)? Please, try to do some tests to show in a graph/table and give quantitative facts. It is not enough to build a device that works, you should test it properly. If does not work, try to test why it fails or test subsystems.
The robot, was originally made with a single set of legs on either side, by that point it was able to wobble around, propelling itself forward in a less than confident way. As the project continued and iterated upon, we added another set of legs on either side, making the robot move in a much more confident fashion. The addition of actuated feet further enhanced its mobility, allowing it to traverse soft surfaces like beds and sofas, as well as uneven and slippery terrain such as grass. During testing we found that the robot was leaning to one side when walking, this was somewhat alleviated by the actuated feet, and replacing one of the leg assemblies. Using the IOS app to control the robot, made the testing process very enjoyable, as the connection between the app and the robot is very responsive. Described below are the findings from our tests based on the requirements proposed earlier. \\
\subsubsection{Scaling}
The robot started of with four legs and was able to walk. When we added four more we could do it by changing the length of the beams and creating a set more, proving that the robot is scalable.
\\
\subsubsection{Bluetooth control}
The bluetooth app works and the robot reacts very quickly when pressing a button.
\\
\subsubsection{Motion}
Several tests have been performed, and the results can be seen in table \ref{tab:speed_test}. The same tests were performed both before and after the addition of actuated feet to see the performance difference. The results shows the speed in seconds how fast it can walk one meter. From the results we observe that the robot was able to walk faster after we added the feet, expect when it walks backwards. \\
Besides walking faster, the robot also walked in a more straight line. While before the actuated feet, we had to do the  tests multiple times as the robot walked off to the side and therefore didn't complete the test. 
\\
\begin{table}[!ht]
    \centering
    \begin{tabular}{|l|l|l|}
    \hline
        Test (speed) & Before feet: seconds & After feet: seconds \\ \hline
        Walking normally (255) & 5,53 & 4,87 \\ \hline
        Walking normally (175) & 7,03 & 6,67 \\ \hline
        Walking backwards (255) & 5,56 & 7,29 \\ \hline
        Walking on grass (255) & 18,88 & 14,78 \\ \hline
    \end{tabular}
    \caption{Results for testing speed}
    \label{tab:speed_test}
\end{table}
\subsubsection{Obstacle detection}
The robot would stop within 16 cm of a wall and is unable to walk forwards, only accepting commands for turning and walking backwards. 

\section{Discussion}
\input{Discussion}
%What are the strengths and shortcomings of your device? Did it match the requirements? How would you improve/develop it further, if you had time? If you had to produce your device in a factory for mass production, what would you modify?

\nocite{*}
\printbibliography
%You can add references, but they are not needed. (All the parts used in your project should be documented in the annexes.)
\clearpage
\onecolumn  
\appendices
\section{Video showcase}
\label{showcase}
Link to Video: \href{https://youtu.be/3B_pobduNls}{https://youtu.be/3B_pobduNls} 
\section{IOS-app code}
\label{swift_code}
\begin{lstlisting}[language=c++]
import SwiftUI
import CoreBluetooth

struct ContentView: View {
    @StateObject private var bluetoothManager = BluetoothManager()
    @State private var speed: Int = 0

    var body: some View {
        ZStack {
            LinearGradient(gradient: Gradient(colors: [.blue.opacity(0.1), 
            .gray.opacity(0.1)]), startPoint: .top, endPoint: .bottom)
                .ignoresSafeArea()

            HStack(spacing: 30) {
                VStack(spacing: 20) {
                    Text("Speed Control")
                        .font(.title2)
                        .bold()
                        .padding(.top, 10)

                    ForEach([("+", 10, "z"), ("++", 25, "x"), ("+++", 50, "c"),
                             ("---", -50, "v"),
                             ("--", -25, "b"), ("-", -10, "n")], id: \.0)
                             { label, change, char in
                        Button(action: {
                            adjustSpeed(by: change, send: char)
                        }) {
                            Text(label)
                                .font(.title2)
                                .frame(width: 70, height: 40)
                                .background(change > 0 ? Color.green.opacity(0.8) : 
                                Color.red.opacity(0.8))
                                .foregroundColor(.white)
                                .cornerRadius(10)
                        }
                    }



                }
                .padding()
                .background(.ultraThinMaterial)
                .cornerRadius(20)
                .shadow(radius: 5)

                VStack(spacing: 10) {
                    VStack(spacing: 5) {
                        ZStack {
                            Circle()
                                .stroke(Color.gray.opacity(0.3), lineWidth: 15)
                                .frame(width: 120, height: 120)

                            Circle()
                                .trim(from: 0.0, to: CGFloat(speed) / 255)
                                .stroke(
                                    AngularGradient
                                    (gradient: Gradient(colors: [.green, .yellow, .red])
                                    , center: .center),
                                    style: StrokeStyle(lineWidth: 15, lineCap: .round)
                                )
                                .rotationEffect(.degrees(-90))
                                .frame(width: 120, height: 120)

                            Text("\(speed)")
                                .font(.title)
                                .bold()
                        }

                        Text("Speed")
                            .font(.subheadline)
                            .foregroundColor(.gray)
                    }
                    .padding(.top, 20)
                    
                    Text("Direction")
                        .font(.title2)
                        .bold()
                        .padding(.top, 10)

                    HStack(spacing: 25) {
                        Spacer()

                        Button(action: {
                            bluetoothManager.sendData("f")
                        }) {
                            Image(systemName: "arrow.up.circle.fill")
                                .resizable()
                                .frame(width: 60, height: 60)
                                .foregroundColor(.blue)
                        }

                        Spacer()
                    }

                    HStack(spacing: 10) {
                        Button(action: {
                            bluetoothManager.sendData("l")
                        }) {
                            Image(systemName: "arrow.left.circle.fill")
                                .resizable()
                                .frame(width: 60, height: 60)
                                .foregroundColor(.blue)
                        }

                        Button(action: {
                            bluetoothManager.sendData("s")
                        }) {
                            Image(systemName: "stop.circle.fill")
                                .resizable()
                                .frame(width: 60, height: 60)
                                .foregroundColor(.red)
                        }

                        Button(action: {
                            bluetoothManager.sendData("r")
                        }) {
                            Image(systemName: "arrow.right.circle.fill")
                                .resizable()
                                .frame(width: 60, height: 60)
                                .foregroundColor(.blue)
                        }
                    }

                    HStack(spacing: 25) {
                        Spacer()
                        Button(action: {
                            bluetoothManager.sendData("b")
                        }) {
                            Image(systemName: "arrow.down.circle.fill")
                                .resizable()
                                .frame(width: 60, height: 60)
                                .foregroundColor(.blue)
                        }
                        Spacer()
                    }
                }
                .padding()
                .background(.ultraThinMaterial)
                .cornerRadius(20)
                .shadow(radius: 5)
            }
            .padding()
        }
        .onAppear {
            bluetoothManager.startScan()
        }
        .onChange(of: bluetoothManager.isConnected) { connected in
            if connected {
                speed = 0
            }
        }
    }

    func adjustSpeed(by amount: Int, send character: String) {
        speed = max(0, min(255, speed + amount))
        bluetoothManager.sendData(character)
    }
}
class BluetoothManager: NSObject, ObservableObject,
CBCentralManagerDelegate, CBPeripheralDelegate {
    var centralManager: CBCentralManager!
    var hm10Peripheral: CBPeripheral!
    let hm10ServiceUUID = CBUUID(string: "FFE0")
    let hm10CharacteristicUUID = CBUUID(string: "FFE1")
    var txCharacteristic: CBCharacteristic?
    @Published var isConnected: Bool = false

    override init() {
        super.init()
        centralManager = CBCentralManager(delegate: self, queue: nil)
    }

    func centralManagerDidUpdateState(_ central: CBCentralManager) {
        if central.state == .poweredOn {
            startScan()
        } else {
            print("Bluetooth not available")
        }
    }

    func startScan() {
        print("Starting scan...")
        centralManager.
        scanForPeripherals(withServices: [hm10ServiceUUID], options: nil)
    }


    func centralManager(_ central: CBCentralManager,
    didDiscover peripheral: CBPeripheral,
    advertisementData: [String : Any], rssi RSSI: NSNumber) {
        print("Discovered \(peripheral.name ?? "Unknown")")
        hm10Peripheral = peripheral
        hm10Peripheral.delegate = self
        centralManager.stopScan()
        centralManager.connect(hm10Peripheral)
    }

    func centralManager(_ central: CBCentralManager,
    didConnect peripheral: CBPeripheral) {
        print("Connected to \(peripheral.name ?? "Unknown")")
        isConnected = true
        peripheral.discoverServices([hm10ServiceUUID])
    }

    func peripheral(_ peripheral: CBPeripheral,
    didDiscoverServices error: Error?) {
        if let services = peripheral.services {
            for service in services {
                peripheral.discoverCharacteristics([hm10CharacteristicUUID], for: service)
            }
        }
    }

    func peripheral(_ peripheral: CBPeripheral,
    didDiscoverCharacteristicsFor service: CBService, error: Error?) {
        if let characteristics = service.characteristics {
            for characteristic in characteristics {
                if characteristic.uuid == hm10CharacteristicUUID {
                    txCharacteristic = characteristic
                    peripheral.setNotifyValue(true, for: characteristic)
                    print("Characteristic connected")
                }
            }
        }
    }

    func sendData(_ message: String) {
        guard let txCharacteristic = txCharacteristic else { return }
        if let data = message.data(using: .utf8) {
            hm10Peripheral.
            writeValue(data, for: txCharacteristic, type: .withoutResponse)
            print("Sent: \(message)")
        }
    }
    
    func centralManager(_ central: CBCentralManager,
    didDisconnectPeripheral peripheral: CBPeripheral, error: (any Error)?) {
        print("Disconnected. Reconnect to try again.")
        startScan()
    }

}



\end{lstlisting}
\section{Arduino code}
\label{arduino_code}
\begin{lstlisting}[language=c++]
#include <SoftwareSerial.h>
SoftwareSerial BT(4,5);
char val; //value to receieve data from the serial port
char moveVal;
char speedVal;
char moveChars[] = {'l', 'r', 'f', 'b', 's'};
int speed = 0;
const int threshold = 20;
const int pingPin = 7;

void setup() {
  
  BT.begin(9600); //Bluetooth serial communications at 9600
  Serial.begin(4800); // Serial communication for logging to terminal
  if( BT.available() ) // check if there is data to read
  {
    val = BT.read(); // read the data into our value variable
  }

  //Setup Channel A
  pinMode(12, OUTPUT); //Initiates Motor Channel A pin
  pinMode(9, OUTPUT); //Initiates Brake Channel A pin

  //Setup Channel B
  pinMode(13, OUTPUT); //Initiates Motor Channel A pin
  pinMode(8, OUTPUT);  //Initiates Brake Channel A pin
  
}


void loop(){

  if( BT.available() ) // check if there is data to read
  {
    val = BT.read(); // read the data into our value variable
    handleVal(val);
  }

  if (measureDistance() < threshold && moveVal == 'f'){
    moveVal = ' ';
    digitalWrite(9, HIGH);  
    digitalWrite(8, HIGH);  
  }

  if (speedVal == 'z'){ // +
    changeSpeed(10);
  }
  if (speedVal == 'x'){ // ++
    changeSpeed(25);
  }
  if (speedVal == 'c'){ // +++
    changeSpeed(50);
  }
  if (speedVal == 'v'){ // ---
    changeSpeed(-50);
  }
  if (speedVal == 'b'){ // --
    changeSpeed(-25);
  }
  if (speedVal == 'n'){ // -
    changeSpeed(-10);
  }

  if (moveVal == 'f') { // Forward
    digitalWrite(12, HIGH); 
    digitalWrite(9, LOW);  
    analogWrite(3, speed);   

    digitalWrite(13, LOW);  
    digitalWrite(8, LOW);   
    analogWrite(11, speed);    
  }
  if (moveVal == 'b') { // Backward 
    digitalWrite(12, LOW); 
    digitalWrite(9, LOW);   
    analogWrite(3, speed);   

    digitalWrite(13, HIGH);  
    digitalWrite(8, LOW);   
    analogWrite(11, speed);    


  }

  if (moveVal == 'r') { // right
    digitalWrite(12, HIGH); 
    digitalWrite(9, LOW);   
    analogWrite(3, speed);   

    digitalWrite(13, HIGH);  
    digitalWrite(8, LOW);   
    analogWrite(11, speed);    
  }

  if (moveVal == 'l') { // left
    digitalWrite(12, LOW); 
    digitalWrite(9, LOW);   
    analogWrite(3, speed);   

    digitalWrite(13, LOW);  
    digitalWrite(8, LOW);   
    analogWrite(11, speed);    

  }
  if (moveVal == 's') { // stop
    digitalWrite(9, HIGH);  
    digitalWrite(8, HIGH);  
  }
  

  delay(100);

  
}

void handleVal(char x){
  // If the value is a direction assign it to the moveval, 
  // which will not be wiped after a loop.
  // Otherwise assign it as the speedval, which will be wiped.
  for (int i = 0; i < sizeof(moveChars); i++) {
    if (x == moveChars[i]) {
      moveVal = val;
      return;
    }
  }
  speedVal = val;
}

// Wrap around function, so the pwm value cannot exceed 255, and go below 0
void changeSpeed(int x){
  if((speed + x) >= 255){
    speed = 255;
    speedVal = ' ';
    return;
  } 
  if ((speed + x) <= -1) {
    speed = 0;
    speedVal = ' ';
    return;
  }
  speedVal = ' ';
  speed = speed + x;
}


int measureDistance(){
  long duration, cm;

  // Send out trigger pulse, to measure afterwards
  pinMode(pingPin, OUTPUT);
  digitalWrite(pingPin, LOW);
  delayMicroseconds(2);
  digitalWrite(pingPin, HIGH);
  delayMicroseconds(4);
  digitalWrite(pingPin, LOW);

  // Measure the duration of the pulse
  pinMode(pingPin, INPUT);
  duration = pulseIn(pingPin, HIGH);

  // convert the time into a distance
  cm = duration / 29 / 2;

  Serial.print(cm);
  Serial.print("cm");
  Serial.println();

  return cm;
}
\end{lstlisting}

\section{Bill of Materials}
\begin{table}[!ht]
    \centering
    \begin{tabular}{|l|l|l|l|}
    \hline
        Component & Quantity & Cost per unit & Subtotal \\ \hline
        Arduino R3 & 1 & kr 236,25 & kr 236,25 \\ \hline
        Heemol L298P Shield R3  & 1 & kr 112 & kr 112 \\\hline
        DSD TECH HM-10 & 1 & 86,16 & 86,16  \\\hline
        DC Motor & 2 & kr 13,05 & kr 26,10 \\ \hline
        Breadboard & 1 & kr 37,95 & kr 37,95 \\ \hline
        Parts for legs & 4 & kr 0,26 & kr 1,04 \\ \hline
        Spur Gear (6 teeth) & 4 & kr 0,03 & kr 0,12 \\ \hline
        Spur Gear (18 teeth) * & 8 & ~ & kr 0,00 \\ \hline
        motorClamp\_left & 1 & kr 0,20 & kr 0,20 \\ \hline
        motorClamp\_right & 1 & kr 0,20 & kr 0,20 \\ \hline
        Gear mounting plate * & 2 & ~ & kr 0,00 \\ \hline
        Baseplate * & 1 & ~ & kr 0,00 \\ \hline
        BEAM 1X1 & 4 & kr 0,34 & kr 1,36 \\ \hline
        CROSS AXLE 6M & 2 & kr 0,91 & kr 1,82 \\ \hline
        Left\_L\_bracket & 1 & kr 0,25 & kr 0,25 \\ \hline
        Right\_L\_bracket & 1 & kr 0,25 & kr 0,25 \\ \hline
        feet\_top & 8 & kr 0,05 & kr 0,40 \\ \hline
        feet\_bottom & 8 & kr 0,04 & kr 0,32 \\ \hline
        hc-sc04  & 1 & kr 0,26 & kr 0,26 \\ \hline
        Rubber bands & 8 & kr 1,27 & kr 10,19 \\ \hline
         &  & Total cost & \underline{kr 514,87}\\ \hline
    \end{tabular}
\end{table}
* we have been unable find the cost of lasercutting

\section{Technical drawings}
\includepdf[pages=-]{Appendix/Technical drawings}
\subsection{Part wise assembly}
\includepdf[pages=-]{Appendix/Part_assembly v1}
\section{Electrical schematics}
\includegraphics[scale = 1.0]{Appendix/Amandatory_exam_schem.png}